
# DFS와 BFS 구현을 정확히 알아야한다.

# DFS는 최대한 멀리있는 노드를 우선으로 탐색하는 방식으로 동작
# DFS는 스택 자료구조에 기초하는 점에서 구현이 간단하다. 실제로는 스택을 쓰지 않아도 되며,
# 데이터의 개수가 N개인 경우에 O(N)의 시간이 소요된다.


# 주어진 그래프에서 연결된 노드를 깊이 우선 탐색으로 방문하는 법
def dfs(graph, v, visited):     # DFS는 스택을 이용한다.  
    # 현재 노드를 방문처리
    visited[v] = True
    print(v, end=" ")   # 방문한 노드들 print하기

    # 현재 노드와 연결된 다른 노드를 재귀적으로 방문
    for i in graph[v]:
        if not visited[i]:              # if not 조건문: ==> 구조 설명: 조건문에 해당하지 않으면 실행하는 if문
            dfs(graph, i, visited)          # 즉 visited[i] == False 일때 실행되는 것이다. ##(visited[i]가 True가 아니니까)

visited = [False] * 9       # 보면 알겠지만, visited는 현재 False가 9개인 방문기록 리스트이다.

graph = [               # 그래프는 노드가 1이 가장 작으므로 인덱스까지 맞추기위해서 0에 빈배열 삽입
    [],             # 
    [2,3,8],        # 1
    [1,7],          # 2
    [1,4,5],        # 3
    [3,5],          # 4
    [3,4],          # 5
    [7],            # 6
    [2,6,8],        # 7
    [1,7]           # 8
]


dfs(graph, 1, visited)






# 한번 더 연습
def dfs2(graph, v, visited):
    visited[v] = True   # 현재 노드 방문처리
    print(v, end=' ')   # 현재 방문처리한 노드 화면 출력

    # 이제 방문 안된 다른 노드들 깊이 탐색으로 방문하러가기, 즉 현재 방문한 노드와 연결된 것들 방문
    for i in graph[v]:
        if not visited[i]:      # 현재 노드와 연결된 노드들 중에서 방문처리 안된거 있으면,
            dfs(graph, i, visited)     # 현재 노드 방문처리 한것처럼 재귀 호출





visited2 = [False]*9        # 노드개수 + 1 (( 0번 노드 추가 인덱스 맞추기 위해서 ))


graph2 = [               # 그래프는 노드가 1이 가장 작으므로 인덱스까지 맞추기위해서 0에 빈배열 삽입
    [],             #
    [2,3,8],        # 1
    [1,7],          # 2
    [1,4,5],        # 3
    [3,5],          # 4
    [3,4],          # 5
    [7],            # 6
    [2,6,8],        # 7
    [1,7]           # 8
]
print()
print("---------------------------------")

dfs2(graph2, 1, visited2)





